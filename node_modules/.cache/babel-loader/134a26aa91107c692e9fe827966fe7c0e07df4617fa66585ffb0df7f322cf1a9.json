{"ast":null,"code":"import { supportsLocalStorage } from './helpers';\n/**\n * @experimental\n */\nexport const internals = {\n  /**\n   * @experimental\n   */\n  debug: !!(globalThis && supportsLocalStorage() && globalThis.localStorage && globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true')\n};\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n *\n * @example\n * ```ts\n * import { LockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * class CustomLockError extends LockAcquireTimeoutError {\n *   constructor() {\n *     super('Lock timed out')\n *   }\n * }\n * ```\n */\nexport class LockAcquireTimeoutError extends Error {\n  constructor(message) {\n    super(message);\n    this.isAcquireTimeout = true;\n  }\n}\n/**\n * Error thrown when the browser Navigator Lock API fails to acquire a lock.\n *\n * @example\n * ```ts\n * import { NavigatorLockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * throw new NavigatorLockAcquireTimeoutError('Lock timed out')\n * ```\n */\nexport class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {}\n/**\n * Error thrown when the process-level lock helper cannot acquire a lock.\n *\n * @example\n * ```ts\n * import { ProcessLockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * throw new ProcessLockAcquireTimeoutError('Lock timed out')\n * ```\n */\nexport class ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {}\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n * @example\n * ```ts\n * await navigatorLock('sync-user', 1000, async () => {\n *   await refreshSession()\n * })\n * ```\n */\nexport async function navigatorLock(name, acquireTimeout, fn) {\n  if (internals.debug) {\n    console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout);\n  }\n  const abortController = new globalThis.AbortController();\n  if (acquireTimeout > 0) {\n    setTimeout(() => {\n      abortController.abort();\n      if (internals.debug) {\n        console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name);\n      }\n    }, acquireTimeout);\n  }\n  // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n  // Wrapping navigator.locks.request() with a plain Promise is done as some\n  // libraries like zone.js patch the Promise object to track the execution\n  // context. However, it appears that most browsers use an internal promise\n  // implementation when using the navigator.locks.request() API causing them\n  // to lose context and emit confusing log messages or break certain features.\n  // This wrapping is believed to help zone.js track the execution context\n  // better.\n  await Promise.resolve();\n  try {\n    return await globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {\n      mode: 'exclusive',\n      ifAvailable: true\n    } : {\n      mode: 'exclusive',\n      signal: abortController.signal\n    }, async lock => {\n      if (lock) {\n        if (internals.debug) {\n          console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name);\n        }\n        try {\n          return await fn();\n        } finally {\n          if (internals.debug) {\n            console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name);\n          }\n        }\n      } else {\n        if (acquireTimeout === 0) {\n          if (internals.debug) {\n            console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name);\n          }\n          throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`);\n        } else {\n          if (internals.debug) {\n            try {\n              const result = await globalThis.navigator.locks.query();\n              console.log('@supabase/gotrue-js: Navigator LockManager state', JSON.stringify(result, null, '  '));\n            } catch (e) {\n              console.warn('@supabase/gotrue-js: Error when querying Navigator LockManager state', e);\n            }\n          }\n          // Browser is not following the Navigator LockManager spec, it\n          // returned a null lock when we didn't use ifAvailable. So we can\n          // pretend the lock is acquired in the name of backward compatibility\n          // and user experience and just run the function.\n          console.warn('@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request');\n          return await fn();\n        }\n      }\n    });\n  } catch (e) {\n    if ((e === null || e === void 0 ? void 0 : e.name) === 'AbortError' && acquireTimeout > 0) {\n      // The lock acquisition was aborted because the timeout fired while the\n      // request was still pending. This typically means another lock holder is\n      // not releasing the lock, possibly due to React Strict Mode's\n      // double-mount/unmount behavior or a component unmounting mid-operation,\n      // leaving an orphaned lock.\n      //\n      // Recovery: use { steal: true } to forcefully acquire the lock. Per the\n      // Web Locks API spec, this releases any currently held lock with the same\n      // name and grants the request immediately, preempting any queued requests.\n      // The previous holder's callback continues running to completion but no\n      // longer holds the lock for exclusion purposes.\n      //\n      // See: https://github.com/supabase/supabase/issues/42505\n      if (internals.debug) {\n        console.log('@supabase/gotrue-js: navigatorLock: acquire timeout, recovering by stealing lock', name);\n      }\n      console.warn(`@supabase/gotrue-js: Lock \"${name}\" was not released within ${acquireTimeout}ms. ` + 'This may indicate an orphaned lock from a component unmount (e.g., React Strict Mode). ' + 'Forcefully acquiring the lock to recover.');\n      return await Promise.resolve().then(() => globalThis.navigator.locks.request(name, {\n        mode: 'exclusive',\n        steal: true\n      }, async lock => {\n        if (lock) {\n          if (internals.debug) {\n            console.log('@supabase/gotrue-js: navigatorLock: recovered (stolen)', name, lock.name);\n          }\n          try {\n            return await fn();\n          } finally {\n            if (internals.debug) {\n              console.log('@supabase/gotrue-js: navigatorLock: released (stolen)', name, lock.name);\n            }\n          }\n        } else {\n          // This should not happen with steal: true, but handle gracefully.\n          console.warn('@supabase/gotrue-js: Navigator LockManager returned null lock even with steal: true');\n          return await fn();\n        }\n      }));\n    }\n    throw e;\n  }\n}\nconst PROCESS_LOCKS = {};\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n * @example\n * ```ts\n * await processLock('migrate', 5000, async () => {\n *   await runMigration()\n * })\n * ```\n */\nexport async function processLock(name, acquireTimeout, fn) {\n  var _a;\n  const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\n  // Wrap previousOperation to handle errors without using .catch()\n  // This avoids Firefox content script security errors\n  const previousOperationHandled = (async () => {\n    try {\n      await previousOperation;\n      return null;\n    } catch (e) {\n      // ignore error of previous operation that we're waiting to finish\n      return null;\n    }\n  })();\n  const currentOperation = (async () => {\n    let timeoutId = null;\n    try {\n      // Wait for either previous operation or timeout\n      const timeoutPromise = acquireTimeout >= 0 ? new Promise((_, reject) => {\n        timeoutId = setTimeout(() => {\n          console.warn(`@supabase/gotrue-js: Lock \"${name}\" acquisition timed out after ${acquireTimeout}ms. ` + 'This may be caused by another operation holding the lock. ' + 'Consider increasing lockAcquireTimeout or checking for stuck operations.');\n          reject(new ProcessLockAcquireTimeoutError(`Acquiring process lock with name \"${name}\" timed out`));\n        }, acquireTimeout);\n      }) : null;\n      await Promise.race([previousOperationHandled, timeoutPromise].filter(x => x));\n      // If we reach here, previousOperationHandled won the race\n      // Clear the timeout to prevent false warnings\n      if (timeoutId !== null) {\n        clearTimeout(timeoutId);\n      }\n    } catch (e) {\n      // Clear the timeout on error path as well\n      if (timeoutId !== null) {\n        clearTimeout(timeoutId);\n      }\n      // Re-throw timeout errors, ignore others\n      if (e && e.isAcquireTimeout) {\n        throw e;\n      }\n      // Fall through to run fn() - previous operation finished with error\n    }\n    // Previous operations finished and we didn't get a race on the acquire\n    // timeout, so the current operation can finally start\n    return await fn();\n  })();\n  PROCESS_LOCKS[name] = (async () => {\n    try {\n      return await currentOperation;\n    } catch (e) {\n      if (e && e.isAcquireTimeout) {\n        // if the current operation timed out, it doesn't mean that the previous\n        // operation finished, so we need continue waiting for it to finish\n        try {\n          await previousOperation;\n        } catch (prevError) {\n          // Ignore previous operation errors\n        }\n        return null;\n      }\n      throw e;\n    }\n  })();\n  // finally wait for the current operation to finish successfully, with an\n  // error or with an acquire timeout error\n  return await currentOperation;\n}","map":{"version":3,"names":["supportsLocalStorage","internals","debug","globalThis","localStorage","getItem","LockAcquireTimeoutError","Error","constructor","message","isAcquireTimeout","NavigatorLockAcquireTimeoutError","ProcessLockAcquireTimeoutError","navigatorLock","name","acquireTimeout","fn","console","log","abortController","AbortController","setTimeout","abort","Promise","resolve","navigator","locks","request","mode","ifAvailable","signal","lock","result","query","JSON","stringify","e","warn","then","steal","PROCESS_LOCKS","processLock","previousOperation","_a","previousOperationHandled","currentOperation","timeoutId","timeoutPromise","_","reject","race","filter","x","clearTimeout","prevError"],"sources":["C:\\Users\\Luis Escorcia T-blue\\Pictures\\chat-app\\chat-app\\node_modules\\@supabase\\auth-js\\src\\lib\\locks.ts"],"sourcesContent":["import { supportsLocalStorage } from './helpers'\n\n/**\n * @experimental\n */\nexport const internals = {\n  /**\n   * @experimental\n   */\n  debug: !!(\n    globalThis &&\n    supportsLocalStorage() &&\n    globalThis.localStorage &&\n    globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true'\n  ),\n}\n\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n *\n * @example\n * ```ts\n * import { LockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * class CustomLockError extends LockAcquireTimeoutError {\n *   constructor() {\n *     super('Lock timed out')\n *   }\n * }\n * ```\n */\nexport abstract class LockAcquireTimeoutError extends Error {\n  public readonly isAcquireTimeout = true\n\n  constructor(message: string) {\n    super(message)\n  }\n}\n\n/**\n * Error thrown when the browser Navigator Lock API fails to acquire a lock.\n *\n * @example\n * ```ts\n * import { NavigatorLockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * throw new NavigatorLockAcquireTimeoutError('Lock timed out')\n * ```\n */\nexport class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {}\n/**\n * Error thrown when the process-level lock helper cannot acquire a lock.\n *\n * @example\n * ```ts\n * import { ProcessLockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * throw new ProcessLockAcquireTimeoutError('Lock timed out')\n * ```\n */\nexport class ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {}\n\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n * @example\n * ```ts\n * await navigatorLock('sync-user', 1000, async () => {\n *   await refreshSession()\n * })\n * ```\n */\nexport async function navigatorLock<R>(\n  name: string,\n  acquireTimeout: number,\n  fn: () => Promise<R>\n): Promise<R> {\n  if (internals.debug) {\n    console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout)\n  }\n\n  const abortController = new globalThis.AbortController()\n\n  if (acquireTimeout > 0) {\n    setTimeout(() => {\n      abortController.abort()\n      if (internals.debug) {\n        console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name)\n      }\n    }, acquireTimeout)\n  }\n\n  // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n\n  // Wrapping navigator.locks.request() with a plain Promise is done as some\n  // libraries like zone.js patch the Promise object to track the execution\n  // context. However, it appears that most browsers use an internal promise\n  // implementation when using the navigator.locks.request() API causing them\n  // to lose context and emit confusing log messages or break certain features.\n  // This wrapping is believed to help zone.js track the execution context\n  // better.\n  await Promise.resolve()\n\n  try {\n    return await globalThis.navigator.locks.request(\n      name,\n      acquireTimeout === 0\n        ? {\n            mode: 'exclusive',\n            ifAvailable: true,\n          }\n        : {\n            mode: 'exclusive',\n            signal: abortController.signal,\n          },\n      async (lock) => {\n        if (lock) {\n          if (internals.debug) {\n            console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name)\n          }\n\n          try {\n            return await fn()\n          } finally {\n            if (internals.debug) {\n              console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name)\n            }\n          }\n        } else {\n          if (acquireTimeout === 0) {\n            if (internals.debug) {\n              console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name)\n            }\n\n            throw new NavigatorLockAcquireTimeoutError(\n              `Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`\n            )\n          } else {\n            if (internals.debug) {\n              try {\n                const result = await globalThis.navigator.locks.query()\n\n                console.log(\n                  '@supabase/gotrue-js: Navigator LockManager state',\n                  JSON.stringify(result, null, '  ')\n                )\n              } catch (e: any) {\n                console.warn(\n                  '@supabase/gotrue-js: Error when querying Navigator LockManager state',\n                  e\n                )\n              }\n            }\n\n            // Browser is not following the Navigator LockManager spec, it\n            // returned a null lock when we didn't use ifAvailable. So we can\n            // pretend the lock is acquired in the name of backward compatibility\n            // and user experience and just run the function.\n            console.warn(\n              '@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request'\n            )\n\n            return await fn()\n          }\n        }\n      }\n    )\n  } catch (e: any) {\n    if (e?.name === 'AbortError' && acquireTimeout > 0) {\n      // The lock acquisition was aborted because the timeout fired while the\n      // request was still pending. This typically means another lock holder is\n      // not releasing the lock, possibly due to React Strict Mode's\n      // double-mount/unmount behavior or a component unmounting mid-operation,\n      // leaving an orphaned lock.\n      //\n      // Recovery: use { steal: true } to forcefully acquire the lock. Per the\n      // Web Locks API spec, this releases any currently held lock with the same\n      // name and grants the request immediately, preempting any queued requests.\n      // The previous holder's callback continues running to completion but no\n      // longer holds the lock for exclusion purposes.\n      //\n      // See: https://github.com/supabase/supabase/issues/42505\n      if (internals.debug) {\n        console.log(\n          '@supabase/gotrue-js: navigatorLock: acquire timeout, recovering by stealing lock',\n          name\n        )\n      }\n\n      console.warn(\n        `@supabase/gotrue-js: Lock \"${name}\" was not released within ${acquireTimeout}ms. ` +\n          'This may indicate an orphaned lock from a component unmount (e.g., React Strict Mode). ' +\n          'Forcefully acquiring the lock to recover.'\n      )\n\n      return await Promise.resolve().then(() =>\n        globalThis.navigator.locks.request(\n          name,\n          {\n            mode: 'exclusive',\n            steal: true,\n          },\n          async (lock) => {\n            if (lock) {\n              if (internals.debug) {\n                console.log(\n                  '@supabase/gotrue-js: navigatorLock: recovered (stolen)',\n                  name,\n                  lock.name\n                )\n              }\n\n              try {\n                return await fn()\n              } finally {\n                if (internals.debug) {\n                  console.log(\n                    '@supabase/gotrue-js: navigatorLock: released (stolen)',\n                    name,\n                    lock.name\n                  )\n                }\n              }\n            } else {\n              // This should not happen with steal: true, but handle gracefully.\n              console.warn(\n                '@supabase/gotrue-js: Navigator LockManager returned null lock even with steal: true'\n              )\n              return await fn()\n            }\n          }\n        )\n      )\n    }\n\n    throw e\n  }\n}\n\nconst PROCESS_LOCKS: { [name: string]: Promise<any> } = {}\n\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n * @example\n * ```ts\n * await processLock('migrate', 5000, async () => {\n *   await runMigration()\n * })\n * ```\n */\nexport async function processLock<R>(\n  name: string,\n  acquireTimeout: number,\n  fn: () => Promise<R>\n): Promise<R> {\n  const previousOperation = PROCESS_LOCKS[name] ?? Promise.resolve()\n\n  // Wrap previousOperation to handle errors without using .catch()\n  // This avoids Firefox content script security errors\n  const previousOperationHandled = (async () => {\n    try {\n      await previousOperation\n      return null\n    } catch (e) {\n      // ignore error of previous operation that we're waiting to finish\n      return null\n    }\n  })()\n\n  const currentOperation = (async () => {\n    let timeoutId: ReturnType<typeof setTimeout> | null = null\n\n    try {\n      // Wait for either previous operation or timeout\n      const timeoutPromise =\n        acquireTimeout >= 0\n          ? new Promise((_, reject) => {\n              timeoutId = setTimeout(() => {\n                console.warn(\n                  `@supabase/gotrue-js: Lock \"${name}\" acquisition timed out after ${acquireTimeout}ms. ` +\n                    'This may be caused by another operation holding the lock. ' +\n                    'Consider increasing lockAcquireTimeout or checking for stuck operations.'\n                )\n\n                reject(\n                  new ProcessLockAcquireTimeoutError(\n                    `Acquiring process lock with name \"${name}\" timed out`\n                  )\n                )\n              }, acquireTimeout)\n            })\n          : null\n\n      await Promise.race([previousOperationHandled, timeoutPromise].filter((x) => x))\n\n      // If we reach here, previousOperationHandled won the race\n      // Clear the timeout to prevent false warnings\n      if (timeoutId !== null) {\n        clearTimeout(timeoutId)\n      }\n    } catch (e: any) {\n      // Clear the timeout on error path as well\n      if (timeoutId !== null) {\n        clearTimeout(timeoutId)\n      }\n\n      // Re-throw timeout errors, ignore others\n      if (e && e.isAcquireTimeout) {\n        throw e\n      }\n      // Fall through to run fn() - previous operation finished with error\n    }\n\n    // Previous operations finished and we didn't get a race on the acquire\n    // timeout, so the current operation can finally start\n    return await fn()\n  })()\n\n  PROCESS_LOCKS[name] = (async () => {\n    try {\n      return await currentOperation\n    } catch (e: any) {\n      if (e && e.isAcquireTimeout) {\n        // if the current operation timed out, it doesn't mean that the previous\n        // operation finished, so we need continue waiting for it to finish\n        try {\n          await previousOperation\n        } catch (prevError) {\n          // Ignore previous operation errors\n        }\n        return null\n      }\n\n      throw e\n    }\n  })()\n\n  // finally wait for the current operation to finish successfully, with an\n  // error or with an acquire timeout error\n  return await currentOperation\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}